# 프로그래밍 러스트

[TOC]

## Ch 1

### 안전성

배열의 잘못된 인덱스를 대입하는 경우, 이를 **미정의 동작**(undefined behaivor)이라고 함

> 미정의 동작 : 본 국제 표준이 요건을 부과하지 않는, 이식할 수 없거나 잘못된 프로그램 구문 요소 또는 잘못된 데이터를 사용할 때의 동작

이는 프로그램의 함수 호출 스택이 깨져 무슨일을 야기할 지 모름

C와 C++는 미정의 동작을 회피하기 위한 규칙이 많지만(ex. 0으로 나누지 않기, 오버플로 조심하기) 컴파일러는 이러한 규칙을 강제하지 않을 뿐 아니라 노골적인 위반을 탐지할 의무조차 지지 않음

이러한 프로그램은 아무런 오류나 경고 없이 컴파일 됨 --> 미정의 동작을 회피할 책임이 전적으로 프로그래머에게 있음

**러스트**의 경우 컴파일러의 여러 검사를 통과한 프로그램에는 대상을 잃은 포인터, 중복 해제, 널 포인터 역참조 같은 미정의 동작이 없게 함

### 병렬 프로그래밍

C와 C++은 동시성(concurrency)을 제대로 이용하기 어려워 보통 싱글 스레드 코드로 필요한 성능을 낼 수 없는 경우에만 동시성에 의지

러스트에서는 메모리 안전성을 책임지는 데 쓰이는 제약이 데이터 경합이 없는 프로그램을 만드는 데도 쓰임

> 데이터 경합 : 여러 스레드에서 공유하는 변수에 대해 동시에 읽기/쓰기 액세스가 진행되는 현상

데이터는 변경되지 않는 한 스레드 간에 자유롭게 공유할 수 있고, 변경되는 데이터는 동기화 기본 요소를 써야만 접근할 수 있음

러스트는 뮤텍스, 조건 변수, 채널, 원자성 지원 등 기존의 동시성 도구들을 전부 사용할 수 있으며, 점검도 해줌

### 빠른 속도

시스템 프로그래밍은 머신을 한계까지 밀어붙이는 일과 관계가 있음

러스트는 효율적인 기본값을 가지고 설계된 언어로서, 메모리의 사용 방식과 프로세서의 관심이 할애되는 방식을 제어할 수 있도록 해줌



## Ch 2

### rustup과 카고

cargo : 러스트의 컴파일 관리자이자 패키지 관리자

rustc : 러스트 컴파일러

rustdoc : 러스트 문서화 도구로, 프로그램의 소스 코드에 적절한 형식의 주석으로 문서를 작성해 두면 이를 가지고 HTML 문서를 만들어줌

```shell
# 명령줄 실행 파일을 빌드하기 위한 hello라는 이름의 새 패키지 디렉터리를 만듦
$ cargo new hello
```

위 명령어를 통해 cargo가 만든 파일 중 **Cargo.toml**은 패키지의 메타데이터를 담아 두는 용도

프로그램이 다른 라이브러리에 대한 의존성을 갖게 될 때 관련된 내용을 이 파일에 기록하여 라이브러리를 내려받고 빌드하며 업데이트 함

**src**는 실제 러스트 코드를 담아 두기 위한 디렉터리

```shell
# 프로그램 빌드 & 실행
$ cargo run
```

실행 파일은 패키지의 최상위에 있는 target 디렉터리에 만들어짐

### 러스트 함수

```rust
fn gcd(mut n: u64, mut m: u64) -> u64 {
    assert!(n != 0 && m != 0);
    while m != 0 {
        if m < n {
            let t = m;
            m = n;
            n = t;
        }
        m = m % n;
    }
    n
}
```

fn 키워드는 함수를 정의

위 함수는 부호 없는 64비트 정수인 u64 타입의 두 매개변수 n과 m을 받아서 u64 값 하나를 반환(-> 토큰 뒤에 있는 것이 반환 타입)

러스트의 머신 정수 타입은 이름에 크기와 부호의 유무가 반영되어 있음

- i32 : 부호 있는 32비트 정수
- u8 : 부호 없는 8비트 정수('바이트' 값을 다룰 때 쓰임)

isize와 usize 타입은 포인터 크기의 부호 있는 정수와 부호 없는 정수를 쥐는데, 32비트 플랫폼에서는 32비트 크기고, 64비트 플랫폼에서는 64비트 크기

러스트의 부동 소수점 타입에는 f32와 f64 두 가지가 있음



기본적으로 변수는 한 번 초기화되고 나면 그 값을 **바꿀 수 없음**

그러나 매개변수 n과 m 앞에 mut키워드(mutable)를 붙이면 함수 본문에서 이들에게 값을 배정할 수 있게 됨



앞서 나온 함수의 본문은 assert! 매크로를 호출하여 두 인수가 모두 0이 아님을 확인하는 것으로 시작

문자 !는 이것이 함수 호출이 아니라 매크로 호출이라는 걸 말해줌

러스트의 assert!는 인수가 참인지 아닌지 검사해 보고 참이 아닐 경우 해당 소스 위치가 포함된 메시지와 함께 프로그램을 종료하는데, 이런 종류의 갑작스러운 종료를 **패닉**이라고 함

C와 C++에서는 단언문을 건너뛸 수 있지만, 러스트는 프로그램이 어떻게 컴파일 되었든 상관없이 항상 단언문을 검사



이 함수의 핵심은 if문과 배정문으로 이뤄진 while 루프

러스트는 C나 C++와 달리 조건식을 괄호로 묶지 않아도 되지만 통제 범위에 있는 실행문들은 반드시 중괄호({ })로 묶어야 함



let문은 위 함수의 t와 같은 지역변수를 선언

러스트는 변수의 쓰임새에서 타입을 추론할 수 있으므로 t의 타입은 적지 않아도 됨

앞의 함수에서 t가 될 수 있는 타입은 m과 n같은 u64뿐임

러스트는 함수 본문 안에 있는 타입만 추론하므로, 함수 매개변수와 반환값의 타입은 적어 주어야 함

t의 타입을 적고 싶다면 다음과 같이 적으면 됨

```rust
let t: u64 = m;
```

러스트는 return 문을 가지고 있지만, gcd 함수에는 필요 X

함수 본문이 세미콜론으로 끝나지 않는 표현식으로 마치면 그것이 함수의 반환값이 됨

중괄호로 묶인 블록은 모두 표현식으로 작용

다음은 메시지를 출력한 뒤 x.cos()를 자신의 값으로 산출하는 표현식

```rust
{
    println!("evaluating cos x");
    x.cos()
}
```

보통 러스트에서는 제어가 함수 '끝에서 떨어지는' 경우에 이런 식으로 함수의 값을 정하며 함수 중간에서 일찍 반환해야 할 때만 return 문을 씀



### 단위 테스트 작성해 돌려보기

러스트는 언어에 간단한 테스트 기능을 내장하고 있음

아래 코드는 앞서 본 gcd 함수를 테스트 하는 함수로 src/main.rs 끝에 삽입

```rust
#[test]
fn test_gcd(){
    assert_eq!(gcd(14,15), 1);

    assert_eq!(gcd(2 * 3 * 5 * 11 * 17, 3 * 7 * 11 * 13 * 19), 3 * 11);
}
```

이 코드는 gcd가 올바른 값을 반환하는지 검사하는 test_gcd라는 함수를 정의

맨 위에 있는 #[test]는 test_gcd가 테스트 함수라는 걸 나타냄

테스트 함수는 보통 컴파일 대상에서는 제외되지만, cargo test 명령으로 프로그램을 실행하면 자동으로 포함되어 호출됨

테스트 함수는 소스 트리 사방에 흩어놔도 되고, 테스트할 코드 바로 옆에 두어도 됨

cargo test는 이들이 어디에 있는 상관없이 전부 모아 실행



#[test]는 **어트리뷰트**의 한 예로, 어트리뷰트는 함수와 기타 다른 선언에 추가 정보를 표시하기 위한 개방형 시스템으로, C++과 C#의 어트리뷰트나 자바의 애너테이션(annotation)과 같다고 보면 됨

컴파일러 경고와 코드 스타일 검사를 제어하고 조건에 따라 포함시킬 코드를 달리 가져가고, 다른 언어로 쓰인 코드를 러스트가 어떻게 다루어야 하는지 알려 주는 등의 일을 하는 데 쓰임

```shell
$ cargo test
```

![image-20231123193401393](./프로그래밍 러스트.assets/image-20231123193401393.png)

### 명령줄 인수 다루기

main 함수를 아래와 같이 수정

```rust
use std::str::FromStr;
use std::env;

fn main() {
    let mut numbers = Vec::new();

    for arg in env::args().skip(1) {
        numbers.push(u64::from_str(&arg).expect("error parsing argument"));
    }
    if numbers.len() == 0 {
        eprintln!("Usage: gcd NUMBER ...");
        std::process::exit(1);
    }

    let mut d = numbers[0];
    for m in &numbers[1..]{
        d = gcd(d, *m);
    }

    println!("The greatest common divisor of {:?} is {}", numbers, d);
}
```



```rust
use std::str::FromStr;
use std::env;
```

첫 번째 **use** 선언문은 표준 라이브러리 트레이트 **FromStr를** 범위 안으로 가져옴

트레이트는 타입이 구현할 수 있는 메서드 모음

**FromStr** 트레이트를 구현하는 모든 타입은 문자열을 해당 타입의 값으로 파싱하는 **from_str** 메서드를 가짐

이 프로그램은 u64 타입이 **FromStr를** 구현하고 있으므로 **u64::from_str**를 호출해 명령줄 인수를 파싱

두 번째 use 선언문은 **std::env** 모듈을 가져옴

이 모듈은 실행 환경과 상호작용하는 데 필요한 여러 가지 유용한 함수와 타입을 제공

**args** 함수를 사용하면 프로그램의 명령줄 인수에 접근할 수 있음



```rust
fn main() {
```

이 프로그램에서는 **main** 함수가 값을 반환하지 않으므로 보통 매개변수 목록 뒤에 오는 ->와 반환 타입을 생략할 수 있음



```rust
let mut numbers = Vec::new();
```

본문의 첫 실행줄은 변경할 수 있는 지역변수 numbers를 선언하고 이를 빈 벡터로 초기화

Vec는 러스트의 벡터 타입으로 C++의 std::vector, 파이썬의 리스트, 자바스크립트의 배열과 비슷

mut를 붙이지 않으면 그 안에 아무것도 넣을 수 없음

numbers의 타입은 u64 값의 벡터인 Vec\<u64>이지만 굳이 적을 필요는 없음

앞서 나온 코드에서 벡터에 들어가는 값이 u64 타입이라는 점과 벡터의 요소를 u64 값만 받는 gcd에 전달한다는 점을 고려해 러스트가 대신 타입을 추론해줌



```rust
for arg in env::args().skip(1) {
```

루프를 한 바퀴 돌 때마다 인수를 하나 가져와서 변수 arg에 설정한 다음 루프 본문을 실행

std::env 모듈의 args 함수는 **이터레이터**를 반환

이 이터레이터는 요구가 있을 때마다 인수를 하나씩 반환하고, 더 이상 반환할 게 없을 때는 없음을 나타내는 값을 반환

표준 라이브러리에는 반복 처리에 적합한 데이터를 손쉽게 다룰 수 있는 거의 모든 종류의 이터레이터가 포함되어 있음

러스트의 이터레이터는 컴파일러가 코드를 옮겨냈을 때의 결과가 손으로 쓴 루프와 차이가 없을 정도로 효율적임

이터레이터는 for 루프와 함께 사용하는 방법 외에도 직접 호출해 쓸 수 있는 여러 종류의 메서드를 가지고 있어서 다양하게 활용 가능

args가 반환하는 이터레이터는 항상 첫 번째 값으로 현재 실행 중인 프로그램의 이름을 주는데 여기서는 이를 건너뛰기 위해서 이터레이터의 skip 메서드를 호출해 이 첫 번째 값이 생략된 새로운 이터레이터를 만듦



```rust
numbers.push(u64::from_str(&arg).expect("error parsing argument"));
```

루프 본문에서는 먼저 u64::from_str를 호출해 명령줄 인수 arg를 부호 없는 64비트 정수로 파싱

from_str 함수는 u64를 직접 반환하지 않고 파싱의 성공 여부를 나타내는 Result 값을 반환

Result 값은 아래 두 베리언트(variant) 중 하나

- Ok(v) : 파싱이 성공했음을 나타내며, v는 결과값
- Err(e) : 파싱이 실패했음을 나타내며, e는 그 이유를 설명하는 오류값

러스트에는 예외가 없음

모든 오류는 Result나 패닉으로 처리

expect는 결과가 Err(e)일 경우 e에 대한 설명이 포함된 메시지를 출력한 뒤 프로그램을 곧바로 종료하지만, 결과가 Ok(v)일 경우에는 단순히 v 자체를 반환하기 때문에 최종적으로 numbers에 넣을 수 있는 값을 얻게 됨



```rust
if numbers.len() == 0 {
    eprintln!("Usage: gcd NUMBER ...");
    std::process::exit(1);
}
```

공집합의 최대공약수는 존재하지 않으므로 위 벡터가 적어도 하나 이상의 요소를 가졌는지 확인해 보고 그렇지 않으면 오류와 함께 프로그램 종료

eprintln! 매크로로 표준 오류 출력 스트림에 오류 메세지 기록



```rust
let mut d = numbers[0];
for m in &numbers[1..]{
    d = gcd(d, *m);
}
```

이 루프는 d를 실행값으로 삼아서 매번 반복할 때마다 그때까지 처리한 모든 수의 최대공약수를 그곳에 유지해줌

d에 변경할 수 있다는 표시(mut)를 해두어야만 루프 안에서 여기다 값을 배정할 수 있음

벡터는 크기가 고정되어 있지 않음

이러한 값을 다룰 때는 그 안에 있는 개별 값의 수명을 확실히 못박아서, 더 이상 필요치 않은 메모리가 지체없이 해제될 수 있게 만들어야 함 --> 프로그래머가 메모리 소모량을 통제

따라서 여기서는 반복 처리를 진행할 때 러스트에게 벡터의 소유권(ownership)이 계속해서 numbers에 남아 있어야 한다고 알림

--> 루프를 위해서 벡터의 요소를 잠시 빌려오기만 하는 것

&numbers[1..]에서 &연산자는 벡터의 두 번째 이후 요소들에 대한 레퍼런스를 빌려옴

이 for 루프는 매번 반복할 때마다 이 참조된 요소들을 차례로 하나씩 m에 빌려옴

*m에서 * 연산자는 m을 역참조해서 그것이 가리키는 값을 넘겨줌 --> 이것이 gcd에 전달할 다음 u64값

끝으로 벡터는 numbers가 소유하기 때문에 numbers가 main의 범위 끝을 벗어나면 자동으로 해제됨

가볍게 &x는 x의 레퍼런스를 빌려오는 것이고 *r은 레퍼런스 r이 참조되는 값



```rust
println!("The greatest common divisor of {:?} is {}", numbers, d);
```

numbers의 모든 요소를 반복 처리하고 난 뒤에는 그 결과를 표준 출력 스트림에 출력

println! 매크로는 템플릿 문자열을 하나 받아서 그 안에 있는 {...} 서식을 순서와 형식에 맞게 나머지 인수로 대체한 뒤 그 결과를 표준 출력 스트림에 기록 <-- 정상 종료 : 0, 틀어졌으면 0이 아닌 다른 수

